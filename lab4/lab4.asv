% dualne: min (t(b)y_1 + t(g)y_2)
% t(A)y_1 + Iy_2 - Iy_3 = c
% y >= 0

% Bazę początkową robimy tak: Jak c jest dodatni, to weź y_2, a jak c jest
% ujemny, to weź y_3

% Uwaga: jak się zmienia znak w wierszu, to trzeba pamietać, żeby potem
% odwrócić z powrotem. Wspomnieć o tym w raporcie, żeby pokazać Ewci, że
% rozumiemy.

% NOTE: Do raportu można mniejsze n i m.

%% Test
n = 5; % Długość wektora c i g
m = 10; % Liczba wierszy macierzy A i długość wektora b

[c, A, b, g] = drawData(n, m);

options = optimoptions('linprog','Display','none','Algorithm','dual-simplex');
[x,fval,exitflag_linprog,output,lambda] = linprog(c, A, b, [], [], zeros(1, n), g, options)

[ZPx, ZDy, exitflag_my] = dualSimplex(c, A, b, g, true)



%% Definicje użytych funkcji

% Metoda simplex do maksymalizacji t(c) * x
% Rozwiązuje metodą dualnego simplexu.
function [ZPx, ZDy, exitflag] = dualSimplex(c, A, b, g, verbose)
    if(verbose)
        disp("Dane wejsciowe: ");
        disp(c);
        disp(A);
        disp(b);
        disp(g);
    end
    exitflag =1;
    [n_rows, n_cols] = size(A');
    A_dual = [A' eye(n_rows) -eye(n_rows)];
    c_dual = [b' g' zeros(1, n_rows)];
    b_dual = c;
    base_indices = zeros(n_rows, 1);
    sign_changed = zeros(n_rows, 1);
    
    % Zamiana wierszy na ujemny i dopisanie odpowiedniego do bazy:
    for i = 1:n_rows
        if(b_dual(i)<0)
            sign_changed(i) = 1;
            base_indices(i) = n_cols + n_rows + i;
            A_dual(i, :) = -A_dual(i, :);
            b_dual(i, :) = -b_dual(i, :);
        else
            base_indices(i) = n_cols + i;
            
        end
    end
    if(verbose)
        disp("Dane przekrztalcone do dualnego:")
        disp(sign_changed);
        disp(A_dual);
        disp(b_dual);
        disp(c_dual);
    end

    % wywołanie zwykłego solvera simplex
    lb = zeros(size(b_dual))';
    [ZDy, ~, exitflag, A_dual, ~, indices] = simplex(-c_dual, A_dual, b_dual, base_indices);
    if(verbose)
        disp("Wyniki obliczen:")
        disp(linprog(c_dual, [], [], A_dual, b_dual, lb))
        disp(ZDy)
    end
    
    % Dostosowanie wyniku dualnego do wyniku prymalnego:
    A_solution = A_dual(:, base_indices);
    for i = 1:n_rows
        if(sign_changed(i) == 1)
            A_solution(:, i) = -A_solution(:, i);
        end
    end
    ZPx = c_dual(indices) * A_solution; % tu rozwiązanie prymalnego
end

% Metoda simplex do maksymalizacji t(c) * x
% Można jej podać z jakich indeksów ma z
function [x, fval, exitflag, A, bf, indices] = simplex(c, A, b, base_indices)
    exitflag = 1;
    maxIter = 10000;
    bf = b;
    cb = c(base_indices);
    z = cb * A;
    zc = z - c;
    
    for iter = 1:maxIter
    
        disp('Obecna tabela:')
        disp([A bf; z inf;zc inf])
    
        disp('Obecne indeksy w bazie:')
        disp(indices)
        if all(zc>=0)
            disp("Znaleziono rozwizanie")
            break;
        end
    
        % znajdz minimalną wartość w wierszu zc
        [~,col]=min(zc);
        if not(any(A(:,col)>0))
            disp("Nie można znaleźć rozwiązania")
            x = inf;
            fval = inf;
            exitflag = 0;
            return
        end
    
        %oblicz wartości b/A dla kolumny z wybraną wartością zc
        set=(bf + eps)./A(:,col);
    
        %znajdz najmniejszą nieujemna wartość w kolumnie
        set(A(:,col)<0)=inf;
        [~,row]=min(set);
    
        % sprowadzamy A(row, col) do 1
        bf(row)=bf(row)/A(row,col);
        A(row,:)=A(row,:)/A(row,col);
      
        t = A(:,col)./A(row,:);
        t =  t(:, col);
        t(row) = 0;
    
        % wyzeruj pozostale wspólczynniki w kolumnie
        Dif=t*A(row,:);
        A=A-Dif;
        
        % przemnóż przez to samo dla prawej kolumny
        bf=bf-bf(row)*t;
    
    
        % zaaktualizuj lewą kolumnę (przy zmiennych bazowych)
        indices(row)=col;
        cb= c(indices)';
        
    
        % oblicz z i z-c
        z=cb' * A;
        zc=z-c;
    end
    % wskaż RO i wartość funkcji
    x = zeros(1, size(A, 2));
    x(indices) = bf';
    fval = sum(c.*x);
end

% Funkcja drawData generuje dane do testów.
function [c, A, b, g] = drawData(n, m)
    % Generowanie wektora c
    c = randi([-5, 5], 1, n);
    
    % Generowanie macierzy A
    A = randi([-5, 5], m, n);
    
    % Generowanie wektora b
    b = randi([-5, 5], 1, m);
    
    % Generowanie wektora g
    g = randi([1, 30], 1, n);
end





















